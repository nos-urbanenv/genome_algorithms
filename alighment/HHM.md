# 隠れマルコフモデルによる配列情報解析(に関する備忘録的まとめ)
隠れマルコフモデルに関する解説の書籍は多数出回っているので、いまさら何を書くべきだろうか？

隠れマルコフモデル*M*は以下のように定義される。
$M = {S,\Sigma, A, E}$
$S = {s_0, s_1, ..., s_{m-1}}$
$A = a_{ij}$
$B = {e(s_i, c_k)=e_i(c_k)=e_{ik}=e(c_k|s_i)}$

配列xが与えられたとき、最も確からしい状態列$\pi$を推定するためのアルゴリズムをViterbiアルゴリズムと呼ぶ。
状態列推定のためにViterbi変数vを定義する。
Viterbi変数は以下のように定義される。

Viterbi変数v_k(t)
$v_k(t) = max_{\pi|\pi_t=s_k}P(x_1...x_t,\pi_1...\pi_t)$
この数式の意味するところは、「時刻tまでに観測された部分列$x_t=x_1...x_t$と時刻tまでの部分状態列$\pi_t=s_1...s_t$の同時確率で、
\pi_t=s_kである場合の確率」

ここで、「同時確率分布」に関して、数理統計学の観点から定義を明確にする必要がある。
数理統計学の知識がない読者は読み飛ばして頂いて構わない。



そのうえで、Viterbiアルゴリズムは定義以下のように表される。
最大確率の状態列を知るために、再帰処理の過程でトレースバック・ポインターptr_t(l)を記録しながら

Initialization $v_0(0)=1, v_0(k)=0 for k>0$
Recursion 
$v_l(i)=e_l(x_i)max_k()$
$$
$$


以上のアルゴリズムをPythonを使って実装してみよう。
入力配列$x$は配列の形で与えられ、


# Viterbiアルゴリズムによる配列解析からスコアモデルへ
BLASTをはじめとするゲノミクスの実用ソフトウェアにおいてはしばしば、確率(掛け算-multiplicationを伴う)ではなく、スコア(加算-additionを伴う)が
用いられる場合が多い。これは主に、長い配列の解析になると複数回の乗算が生じ、浮動小数点演算に起因する誤差が生じてしまうことが原因である。

しかしながら、Viterbiアルゴリズムで示したような確率モデルによる配列情報解析と、加算型のスコアによる配列情報解析は数学的に等価である。
以下ではそのことを示そう。

Viterbiアルゴリズムによる解析からもわかる通り、確率モデルによる解析では状態遷移のたびに確率の乗算が行われる。
乗算を加算に変えるためには、Viterbiアルゴリズムの再帰式の両辺をlogで変換すればよい。
logで変換した後のViterbiアルゴリズムは以下のように定義できる。

Log変換した後のViterbiアルゴリズム
Initialization $$


得られた、最も確からしい配列\piが得られる確率


